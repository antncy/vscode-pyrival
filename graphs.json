{
    "Bellman-Ford Algorithm Template": {
        "prefix": "graph.bellman",
        "body": [
          "def bellman_ford(n, edges, start):",
          "    dist = [float(\"inf\")] * n",
          "    pred = [None] * n",
          "",
          "    dist[start] = 0",
          "",
          "    for _ in range(n):",
          "        for u, v, d in edges:",
          "            if dist[u] + d < dist[v]:",
          "                dist[v] = dist[u] + d",
          "                pred[v] = u",
          "    \"\"\"Sanity Check",
          "    for u, v, d in edges:",
          "        if dist[u] + d < dist[v]:",
          "            return None",
          "    \"\"\"",
          "",
          "    return dist, pred",
          "",
          ""
        ],
        "description": "Bellman-Ford Algorithm Template"
      },

      "Breadth First Search Template": {
        "prefix": "graph.bfs",
        "body": [
          "def bfs(graph, start=0):",
          "    used = [False] * len(graph)",
          "    used[start] = True",
          "    q = [start]",
          "    for v in q:",
          "        for w in graph[v]:",
          "            if not used[w]:",
          "                used[w] = True",
          "                q.append(w)",
          "",
          "",
          "def layers(graph, start=0):",
          "    used = [False] * len(graph)",
          "    used[start] = True",
          "    q, ret = [start], []",
          "    while q:",
          "        nq = []",
          "        ret.append(q)",
          "        for v in q:",
          "            for w in graph[v]:",
          "                if not used[w]:",
          "                    used[w] = True",
          "                    nq.append(w)",
          "        q = nq",
          "    return ret",
          "",
          ""
        ],
        "description": "Breadth First Search Template"
      },

      "Connected Components Search Template": {
        "prefix": "graph.ccs",
        "body": [
          "def connected_components(n, graph):",
          "    components, visited = [], [False] * n",
          "",
          "    def dfs(start):",
          "        component, stack = [], [start]",
          "",
          "        while stack:",
          "            start = stack[-1]",
          "",
          "            if visited[start]:",
          "                stack.pop()",
          "                continue",
          "            else:",
          "                visited[start] = True",
          "                component.append(start)",
          "",
          "            for i in graph[start]:",
          "                if not visited[i]:",
          "                    stack.append(i)",
          "",
          "        return component",
          "",
          "    for i in range(n):",
          "        if not visited[i]:",
          "            components.append(dfs(i))",
          "",
          "    return components",
          "",
          ""
        ],
        "description": "Connected Components Search Template"
      },

      "Brent's Algorithm for Cycle Detection Template": {
        "prefix": "graph.brent",
        "body": [
          "def cycle_finding(f, x0):",
          "    # main phase: search successive powers of two",
          "    power = lam = 1",
          "    tortoise = x0",
          "    hare = f(x0)  # f(x0) is the element/node next to x0.",
          "    while tortoise != hare:",
          "        if power == lam:  # time to start a new power of two?",
          "            tortoise = hare",
          "            power *= 2",
          "            lam = 0",
          "        hare = f(hare)",
          "        lam += 1",
          "",
          "    # Find the position of the first repetition of length lam",
          "    mu = 0",
          "    tortoise = hare = x0",
          "    for _ in range(lam):",
          "        hare = f(hare)",
          "    # The distance between the hare and tortoise is now lam.",
          "",
          "    # Next, the hare and tortoise move at same speed until they agree",
          "    while tortoise != hare:",
          "        tortoise = f(tortoise)",
          "        hare = f(hare)",
          "        mu += 1",
          "",
          "    return lam, mu",
          "",
          ""
        ],
        "description": "Brent's Algorithm for Cycle Detection Template"
      },

      "Depth First Search Template": {
        "prefix": "graph.dfs",
        "body": [
          "def dfs(graph, start=0):",
          "    n = len(graph)",
          "",
          "    dp = [0] * n",
          "    visited, finished = [False] * n, [False] * n",
          "",
          "    stack = [start]",
          "    while stack:",
          "        start = stack[-1]",
          "",
          "        # push unvisited children into stack",
          "        if not visited[start]:",
          "            visited[start] = True",
          "            for child in graph[start]:",
          "                if not visited[child]:",
          "                    stack.append(child)",
          "",
          "        else:",
          "            stack.pop()",
          "",
          "            # base case",
          "            dp[start] += 1",
          "",
          "            # update with finished children",
          "            for child in graph[start]:",
          "                if finished[child]:",
          "                    dp[start] += dp[child]",
          "",
          "            finished[start] = True",
          "",
          "    return visited, dp",
          "",
          ""
        ],
        "description": "Depth First Search Template"
      },

      "Dijkstra's Algorithm Template": {
        "prefix": "graph.dijkstra",
        "body": [
          "from heapq import heappop, heappush",
          "",
          "",
          "def dijkstra(graph, start):",
          "    \"\"\" ",
          "        Uses Dijkstra's algortihm to find the shortest path from node start",
          "        to all other nodes in a directed weighted graph.",
          "    \"\"\"",
          "    n = len(graph)",
          "    dist, parents = [float(\"inf\")] * n, [-1] * n",
          "    dist[start] = 0",
          "",
          "    queue = [(0, start)]",
          "    while queue:",
          "        path_len, v = heappop(queue)",
          "        if path_len == dist[v]:",
          "            for w, edge_len in graph[v]:",
          "                if edge_len + path_len < dist[w]:",
          "                    dist[w], parents[w] = edge_len + path_len, v",
          "                    heappush(queue, (edge_len + path_len, w))",
          "",
          "    return dist, parents",
          "",
          ""
        ],
        "description": "Dijkstra's Algorithm Template"
      },

      "Eulerian Path Template": {
        "prefix": "graph.euler",
        "body": [
          "def euler_walk(n, adj):",
          "    deg = [0] * n",
          "",
          "    for i in range(n):",
          "        for j in range(n):",
          "            deg[i] += adj[i][j]",
          "",
          "    first = 0",
          "    while deg[first] == 0:",
          "        first += 1",
          "",
          "    v1, v2 = -1, -1",
          "    bad = False",
          "",
          "    for i in range(n):",
          "        if deg[i] % 2 == 1:",
          "            if v1 == -1:",
          "                v1 = i",
          "            elif v2 == -1:",
          "                v2 = i",
          "            else:",
          "                bad = True",
          "",
          "    if v1 != -1:",
          "        adj[v1][v2] += 1",
          "        adj[v2][v1] += 1",
          "",
          "    st, res = [first], []",
          "",
          "    while st:",
          "        v = st[-1]",
          "        flag = False",
          "",
          "        for i in range(n):",
          "            if adj[v][i]:",
          "                flag = True",
          "                break",
          "",
          "        if flag:",
          "            adj[v][i] -= 1",
          "            adj[i][v] -= 1",
          "            st.append(i)",
          "        else:",
          "            res.append(v)",
          "            st.pop()",
          "",
          "    if v1 != -1:",
          "        for i in range(len(res) - 1):",
          "            if ((res[i] == v1) and (res[i + 1] == v2)) or ((res[i] == v2) and (res[i + 1] == v1)):",
          "                res = [res[j] for j in range(i + 1, len(res))] + [res[j] for j in range(1, i + 1)]",
          "                break",
          "",
          "    for i in range(n):",
          "        for j in range(n):",
          "            if adj[i][j]:",
          "                bad = True",
          "",
          "    if bad:",
          "        return None",
          "",
          "    return res",
          "",
          ""
        ],
        "description": "Eulerian Path Template"
      },

      "Path Constructor Template": {
        "prefix": "graph.pathcon",
        "body": [
          "def find_path(start, end, parents):",
          "    \"\"\" Constructs a path between two vertices, given the parents of all vertices. \"\"\"",
          "    path, parent = [], end",
          "",
          "    while parent != parents[start]:",
          "        path.append(parent)",
          "        parent = parents[parent]",
          "",
          "    return path[::-1]",
          "",
          ""
        ],
        "description": "Path Constructor Template"
      },

      "Floyd-Warshall Algorithm Template": {
        "prefix": "graph.floyd",
        "body": [
          "def floyd_warshall(n, edges):",
          "    dist = [[0 if i == j else float(\"inf\") for i in range(n)] for j in range(n)]",
          "    pred = [[None] * n for _ in range(n)]",
          "",
          "    for u, v, d in edges:",
          "        dist[u][v] = d",
          "        pred[u][v] = u",
          "",
          "    for k in range(n):",
          "        for i in range(n):",
          "            for j in range(n):",
          "                if dist[i][k] + dist[k][j] < dist[i][j]:",
          "                    dist[i][j] = dist[i][k] + dist[k][j]",
          "                    pred[i][j] = pred[k][j]",
          "    \"\"\"Sanity Check",
          "    for u, v, d in edges:",
          "        if dist[u] + d < dist[v]:",
          "            return None",
          "    \"\"\"",
          "",
          "    return dist, pred",
          "",
          ""
        ],
        "description": "Floyd-Warshall Algorithm Template"
      },

      "Bipartite Graph Check Template": {
        "prefix": "graph.bcheck",
        "body": [
          "def is_bipartite(graph):",
          "    n = len(graph)",
          "    color = [-1] * n",
          "",
          "    for start in range(n):",
          "        if color[start] == -1:",
          "            color[start] = 0",
          "            stack = [start]",
          "",
          "            while stack:",
          "                parent = stack.pop()",
          "",
          "                for child in graph[parent]:",
          "                    if color[child] == -1:",
          "                        color[child] = 1 - color[parent]",
          "                        stack.append(child)",
          "                    elif color[parent] == color[child]:",
          "                        return False, color",
          "",
          "    return True, color",
          "",
          ""
        ],
        "description": "Bipartite Graph Check Template"
      },

      "Kruskal's Algorithm with Disjoin Set Union Template": {
        "prefix": "graph.kruskal",
        "body": [
          "class UnionFind:",
          "    def __init__(self, n):",
          "        self.parent = list(range(n))",
          "",
          "    def find(self, a):",
          "        acopy = a",
          "        while a != self.parent[a]:",
          "            a = self.parent[a]",
          "        while acopy != a:",
          "            self.parent[acopy], acopy = a, self.parent[acopy]",
          "        return a",
          "",
          "    def merge(self, a, b):",
          "        self.parent[self.find(b)] = self.find(a)",
          "",
          "",
          "def kruskal(n, U, V, W):",
          "    union = UnionFind(n)",
          "    cost, merge_cnt = 0, 0",
          "    mst_u, mst_v = [], []",
          "    order = sorted(range(len(W)), key=lambda x: W[x])",
          "    for i in range(len(W)):",
          "        u, v = U[order[i]], V[order[i]]",
          "        find_u, find_v = union.find(u), union.find(v)",
          "        if find_u != find_v:",
          "            cost += W[order[i]]",
          "            merge_cnt += 1",
          "            union.parent[find_v] = find_u",
          "            mst_u.append(u), mst_v.append(v)",
          "",
          "    return cost, mst_u, mst_v, n == 1 + merge_cnt",
          "",
          ""
        ],
        "description": "Kruskal's Algorithm with Disjoin Set Union Template"
      },

      "Prim's Algorithm Template": {
        "prefix": "graph.prim",
        "body": [
          "def prim(n, adj):",
          "    total_weight = 0",
          "    selected, min_e = [False] * n, [[float(\"inf\"), -1] for _ in range(n)]",
          "    mst_edges = []",
          "",
          "    min_e[0][0] = 0",
          "",
          "    for i in range(n):",
          "        v = -1",
          "",
          "        for j in range(n):",
          "            if (not selected[j]) and ((v == -1) or (min_e[j][0] < min_e[v][0])):",
          "                v = j",
          "",
          "        if min_e[v][0] == float(\"inf\"):",
          "            return None, None",
          "",
          "        selected[v] = True",
          "        total_weight += min_e[v][0]",
          "",
          "        if min_e[v][1] != -1:",
          "            mst_edges.append((v, min_e[v][1]))",
          "",
          "        for to in range(n):",
          "            if adj[v][to] < min_e[to][0]:",
          "                min_e[to] = [adj[v][to], v]",
          "",
          "    return mst_edges, total_weight",
          "",
          ""
        ],
        "description": "Prim's Algorithm Template"
      },

      "Tarjan's Algorithm Template": {
        "prefix": "graph.tarjan",
        "body": [
          "def find_SCC(graph):",
          "    SCC, S, P = [], [], []",
          "    depth = [0] * len(graph)",
          " ",
          "    stack = list(range(len(graph)))",
          "    while stack:",
          "        node = stack.pop()",
          "        if node < 0:",
          "            d = depth[~node] - 1",
          "            if P[-1] > d:",
          "                SCC.append(S[d:])",
          "                del S[d:], P[-1]",
          "                for node in SCC[-1]:",
          "                    depth[node] = -1",
          "        elif depth[node] > 0:",
          "            while P[-1] > depth[node]:",
          "                P.pop()",
          "        elif depth[node] == 0:",
          "            S.append(node)",
          "            P.append(len(S))",
          "            depth[node] = len(S)",
          "            stack.append(~node)",
          "            stack += graph[node]",
          "    return SCC[::-1]",
          "",
          ""
        ],
        "description": "Tarjan's Algorithm Template"
      },

      "Topological Sorting Template": {
        "prefix": "graph.sorttop",
        "body": [
          "# from heapq import heappop, heappush",
          "",
          "def toposort(graph):",
          "    res, found = [], [0] * len(graph)",
          "    stack = list(range(len(graph)))",
          "    while stack:",
          "        node = stack.pop()",
          "        if node < 0:",
          "            res.append(~node)",
          "        elif not found[node]:",
          "            found[node] = 1",
          "            stack.append(~node)",
          "            stack += graph[node]",
          "",
          "    # cycle check",
          "    for node in res:",
          "        if any(found[nei] for nei in graph[node]):",
          "            return None",
          "        found[node] = 0",
          "",
          "    return res[::-1]",
          "",
          "",
          "def kahn(graph):",
          "    n = len(graph)",
          "",
          "    indeg, idx = [0] * n, [0] * n",
          "    for i in range(n):",
          "        for e in graph[i]:",
          "            indeg[e] += 1",
          "",
          "    q, res = [], []",
          "    for i in range(n):",
          "        if indeg[i] == 0:",
          "            q.append(i)  # heappush(q, -i)",
          "",
          "    nr = 0",
          "    while q:",
          "        res.append(q.pop())  # res.append(-heappop(q))",
          "        idx[res[-1]], nr = nr, nr + 1",
          "        for e in graph[res[-1]]:",
          "            indeg[e] -= 1",
          "            if indeg[e] == 0:",
          "                q.append(e)  # heappush(q, -e)",
          "",
          "    return res, idx, nr == n",
          "",
          ""
        ],
        "description": "Topological Sorting Template"
      },

      




}