{
    "Bit Array Template": {
        "prefix": "!barr",
        "body": [
          "class BitArray:",
          "    \"\"\"implements bitarray using bytearray\"\"\"",
          "    def __init__(self, size):",
          "        self.bytes = bytearray((size >> 3) + 1)",
          "",
          "    def __getitem__(self, index):",
          "        return (self.bytes[index >> 3] >> (index & 7)) & 1",
          "",
          "    def __setitem__(self, index, value):",
          "        if value:",
          "            self.bytes[index >> 3] |= 1 << (index & 7)",
          "        else:",
          "            self.bytes[index >> 3] &= ~(1 << (index & 7))",
          "",
          "$1"
        ],
        "description": "Bit Array Template"
      },

      "Binary Indexed (Fenwick) Tree Template": {
        "prefix": "!bitree",
        "body": [
          "class FenwickTree:",
          "    def __init__(self, x):",
          "        \"\"\"transform list into BIT\"\"\"",
          "        self.bit = x",
          "        for i in range(len(x)):",
          "            j = i | (i + 1)",
          "            if j < len(x):",
          "                x[j] += x[i]",
          "",
          "    def update(self, idx, x):",
          "        \"\"\"updates bit[idx] += x\"\"\"",
          "        while idx < len(self.bit):",
          "            self.bit[idx] += x",
          "            idx |= idx + 1",
          "",
          "    def query(self, end):",
          "        \"\"\"calc sum(bit[:end])\"\"\"",
          "        x = 0",
          "        while end:",
          "            x += self.bit[end - 1]",
          "            end &= end - 1",
          "        return x",
          "",
          "    def findkth(self, k):",
          "        \"\"\"Find largest idx such that sum(bit[:idx]) <= k\"\"\"",
          "        idx = -1",
          "        for d in reversed(range(len(self.bit).bit_length())):",
          "            right_idx = idx + (1 << d)",
          "            if right_idx < len(self.bit) and k >= self.bit[right_idx]:",
          "                idx = right_idx",
          "                k -= self.bit[idx]",
          "        return idx + 1",
          "",
          "$1"
        ],
        "description": "Binary Indexed (Fenwick) Tree Template"
      },

      "Fraction Template": {
        "prefix": "!frac",
        "body": [
          "def gcd(x, y):",
          "    \"\"\"greatest common divisor of x and y\"\"\"",
          "    while y:",
          "        x, y = y, x % y",
          "    return x",
          "",
          "",
          "class Fraction:",
          "    def __init__(self, num=0, den=1):",
          "        g = gcd(num, den)",
          "        self.num, self.den = num // g, den // g",
          "",
          "    __add__ = lambda self, other: Fraction(self.num * other.den + other.num * self.den, self.den * other.den)",
          "    __sub__ = lambda self, other: Fraction(self.num * other.den - other.num * self.den, self.den * other.den)",
          "    __mul__ = lambda self, other: Fraction(self.num * other.num, self.den * other.den)",
          "    __truediv__ = lambda self, other: Fraction(self.num * other.den, self.den * other.num)",
          "    __floordiv__ = lambda self, other: (self.num * other.den) // (self.den * other.num)",
          "",
          "    __pow__ = lambda self, other: Fraction(self.num**other, self.den**other)",
          "    __abs__ = lambda self: self if self.num >= 0 else Fraction(-self.num, self.den)",
          "    __neg__ = lambda self: Fraction(-self.num, self.den)",
          "    __round__ = lambda self, ndigits: round(self.num / self.den, ndigits)",
          "",
          "    __bool__ = lambda self: bool(self.num)",
          "    __int__ = lambda self: self.num // self.den",
          "    __float__ = lambda self: self.num / self.den",
          "    __str__ = lambda self: \"({}, {})\".format(self.num, self.den)",
          "",
          "    __copy__ = lambda self: Fraction(self.num, self.den)",
          "    __hash__ = lambda self: hash((self.num, self.den))",
          "",
          "    __eq__ = lambda self, other: self.num * other.den == other.num * self.den",
          "    __ne__ = lambda self, other: self.num * other.den != other.num * self.den",
          "    __lt__ = lambda self, other: self.num * other.den < other.num * self.den",
          "    __gt__ = lambda self, other: self.num * other.den > other.num * self.den",
          "    __le__ = lambda self, other: self.num * other.den <= other.num * self.den",
          "    __ge__ = lambda self, other: self.num * other.den >= other.num * self.den",
          "",
          "    __repr__ = lambda self: \"Fraction({}, {})\".format(self.num, self.den)",
          "",
          "",
          "def limit_denominator(frac, max_den=1000000):",
          "    if frac.den <= max_den:",
          "        return frac",
          "",
          "    p0, q0, p1, q1 = 0, 1, 1, 0",
          "    n, d = frac.num, frac.den",
          "    while True:",
          "        a = n // d",
          "        q2 = q0 + a * q1",
          "        if q2 > max_den:",
          "            break",
          "        p0, q0, p1, q1 = p1, q1, p0 + a * p1, q2",
          "        n, d = d, n - a * d",
          "",
          "    k = (max_den - q0) // q1",
          "    bound1 = Fraction(p0 + k * p1, q0 + k * q1)",
          "    bound2 = Fraction(p1, q1)",
          "    return bound2 if abs(bound2 - frac) <= abs(bound1 - frac) else bound1",
          "",
          "$1"
        ],
        "description": "Fraction Template"
      },

      "Continued Fraction Template": {
        "prefix": "!cfrac",
        "body": [
          "def CFraction(frac):",
          "    num, den = frac",
          "    yield num // den",
          "    num %= den",
          "    while den != 1:",
          "        num, den = den, num",
          "        yield num // den",
          "        num %= den",
          "",
          "",
          "def CFrac2Frac(cfrac):",
          "    num, den = 1, 0",
          "    for u in reversed(cfrac):",
          "        num, den = den + num * u, num",
          "    return (num, den)",
          "",
          "$1"
        ],
        "description": "Continued Fraction Template"
      },

      "Disjoint-Set (Union Find) Template": {
        "prefix": "!dset",
        "body": [
          "class DisjointSetUnion:",
          "    def __init__(self, n):",
          "        self.parent = list(range(n))",
          "        self.size = [1] * n",
          "        self.num_sets = n",
          "",
          "    def find(self, a):",
          "        acopy = a",
          "        while a != self.parent[a]:",
          "            a = self.parent[a]",
          "        while acopy != a:",
          "            self.parent[acopy], acopy = a, self.parent[acopy]",
          "        return a",
          "",
          "    def union(self, a, b):",
          "        a, b = self.find(a), self.find(b)",
          "        if a != b:",
          "            if self.size[a] < self.size[b]:",
          "                a, b = b, a",
          "",
          "            self.num_sets -= 1",
          "            self.parent[b] = a",
          "            self.size[a] += self.size[b]",
          "",
          "    def set_size(self, a):",
          "        return self.size[self.find(a)]",
          "",
          "    def __len__(self):",
          "        return self.num_sets",
          "",
          "",
          "class UnionFind:",
          "    def __init__(self, n):",
          "        self.parent = list(range(n))",
          "",
          "    def find(self, a):",
          "        acopy = a",
          "        while a != self.parent[a]:",
          "            a = self.parent[a]",
          "        while acopy != a:",
          "            self.parent[acopy], acopy = a, self.parent[acopy]",
          "        return a",
          "",
          "    def union(self, a, b):",
          "        self.parent[self.find(b)] = self.find(a)",
          "",
          "$1"
        ],
        "description": "Disjoint-Set (Union Find) Template"
      },

      "Generic Nodes Template": {
        "prefix": "!node",
        "body": [
          "class Node:",
          "    def __init__(self, value):",
          "        self.value = value",
          "        self.next = None",
          "        self.prev = None",
          "",
          "    def __repr__(self):",
          "        if not self:",
          "            return \"{}()\".format(self.__class__.__name__)",
          "        return \"{}({})\".format(self.__class__.__name__, self.value)",
          "",
          "$1"
        ],
        "description": "Generic Nodes Template"
      },

      "Linked List Template": {
        "prefix": "!llist",
        "body": [
          "class Node:",
          "    def __init__(self, value):",
          "        self.value = value",
          "        self.next = None",
          "        self.prev = None",
          "",
          "    def __repr__(self):",
          "        if not self:",
          "            return \"{}()\".format(self.__class__.__name__)",
          "        return \"{}({})\".format(self.__class__.__name__, self.value)",
          "",
          "",
          "class LinkedList:",
          "    def __init__(self, iterable=None):",
          "        self.sentinel = Node(None)",
          "        self.sentinel.next = self.sentinel",
          "        self.sentinel.prev = self.sentinel",
          "        self.__len = 0",
          "        if iterable is not None:",
          "            self += iterable",
          "",
          "    def get_node(self, index):",
          "        node = self.sentinel",
          "        i = 0",
          "        while i <= index:",
          "            node = node.next",
          "            if node == self.sentinel:",
          "                break",
          "            i += 1",
          "        if node == self.sentinel:",
          "            node = None",
          "        return node",
          "",
          "    def __getitem__(self, index):",
          "        node = self.get_node(index)",
          "        return node.value",
          "",
          "    def __len__(self):",
          "        return self.__len",
          "",
          "    def __setitem__(self, index, value):",
          "        node = self.get_node(index)",
          "        node.value = value",
          "",
          "    def __delitem__(self, index):",
          "        node = self.get_node(index)",
          "        if node:",
          "            node.prev.next = node.next",
          "            if node.next:",
          "                node.next.prev = node.prev",
          "            node.prev = None",
          "            node.next = None",
          "            node.value = None",
          "            self.__len -= 1",
          "",
          "    def __repr__(self):",
          "        return str(self.to_list())",
          "",
          "    def to_list(self):",
          "        elts = []",
          "        curr = self.sentinel.next",
          "        while curr != self.sentinel:",
          "            elts.append(curr.value)",
          "            curr = curr.next",
          "        return elts",
          "",
          "    def append(self, value):",
          "        node = Node(value)",
          "        self.insert_between(node, self.sentinel.prev, self.sentinel)",
          "",
          "    def appendleft(self, value):",
          "        node = Node(value)",
          "        self.insert_between(node, self.sentinel, self.sentinel.next)",
          "",
          "    def insert(self, index, value):",
          "        new_node = Node(value)",
          "        len_ = len(self)",
          "        if len_ == 0:",
          "            self.insert_between(new_node, self.sentinel, self.sentinel)",
          "        elif index >= 0 and index < len_:",
          "            node = self.get_node(index)",
          "            self.insert_between(new_node, node.prev, node)",
          "        elif index == len_:",
          "            self.insert_between(new_node, self.sentinel.prev, self.sentinel)",
          "        else:",
          "            raise IndexError",
          "        self.__len += 1",
          "",
          "    def insert_between(self, node, left_node, right_node):",
          "        if node and left_node and right_node:",
          "            node.prev = left_node",
          "            node.next = right_node",
          "            left_node.next = node",
          "            right_node.prev = node",
          "        else:",
          "            raise IndexError",
          "",
          "    def merge_left(self, other):",
          "        self.sentinel.next.prev = other.sentinel.prev",
          "        other.sentinel.prev.next = self.sentinel.next",
          "        self.sentinel.next = other.sentinel.next",
          "        self.sentinel.next.prev = self.sentinel",
          "",
          "    def merge_right(self, other):",
          "        self.sentinel.prev.next = other.sentinel.next",
          "        other.sentinel.next.prev = self.sentinel.prev",
          "        self.sentinel.prev = other.sentinel.prev",
          "        self.sentinel.prev.next = self.sentinel",
          "",
          "$1"
        ],
        "description": "Linked List Template"
      }


      


}