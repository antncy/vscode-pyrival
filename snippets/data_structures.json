{
  "Bit Array Template": {
      "prefix": "ds.barr",
      "body": [
        "class BitArray:",
        "    \"\"\"implements bitarray using bytearray\"\"\"",
        "    def __init__(self, size):",
        "        self.bytes = bytearray((size >> 3) + 1)",
        "",
        "    def __getitem__(self, index):",
        "        return (self.bytes[index >> 3] >> (index & 7)) & 1",
        "",
        "    def __setitem__(self, index, value):",
        "        if value:",
        "            self.bytes[index >> 3] |= 1 << (index & 7)",
        "        else:",
        "            self.bytes[index >> 3] &= ~(1 << (index & 7))",
        "",
        "$1"
      ],
      "description": "Bit Array Template"
    },

    "Binary Indexed (Fenwick) Tree Template": {
      "prefix": "ds.ftree",
      "body": [
        "class FenwickTree:",
        "    def __init__(self, x):",
        "        \"\"\"transform list into BIT\"\"\"",
        "        self.bit = x",
        "        for i in range(len(x)):",
        "            j = i | (i + 1)",
        "            if j < len(x):",
        "                x[j] += x[i]",
        "",
        "    def update(self, idx, x):",
        "        \"\"\"updates bit[idx] += x\"\"\"",
        "        while idx < len(self.bit):",
        "            self.bit[idx] += x",
        "            idx |= idx + 1",
        "",
        "    def query(self, end):",
        "        \"\"\"calc sum(bit[:end])\"\"\"",
        "        x = 0",
        "        while end:",
        "            x += self.bit[end - 1]",
        "            end &= end - 1",
        "        return x",
        "",
        "    def findkth(self, k):",
        "        \"\"\"Find largest idx such that sum(bit[:idx]) <= k\"\"\"",
        "        idx = -1",
        "        for d in reversed(range(len(self.bit).bit_length())):",
        "            right_idx = idx + (1 << d)",
        "            if right_idx < len(self.bit) and k >= self.bit[right_idx]:",
        "                idx = right_idx",
        "                k -= self.bit[idx]",
        "        return idx + 1",
        "",
        "$1"
      ],
      "description": "Binary Indexed (Fenwick) Tree Template"
    },

    "Fraction Template": {
      "prefix": "ds.frac",
      "body": [
        "def gcd(x, y):",
        "    \"\"\"greatest common divisor of x and y\"\"\"",
        "    while y:",
        "        x, y = y, x % y",
        "    return x",
        "",
        "",
        "class Fraction:",
        "    def __init__(self, num=0, den=1):",
        "        g = gcd(num, den)",
        "        self.num, self.den = num // g, den // g",
        "",
        "    __add__ = lambda self, other: Fraction(self.num * other.den + other.num * self.den, self.den * other.den)",
        "    __sub__ = lambda self, other: Fraction(self.num * other.den - other.num * self.den, self.den * other.den)",
        "    __mul__ = lambda self, other: Fraction(self.num * other.num, self.den * other.den)",
        "    __truediv__ = lambda self, other: Fraction(self.num * other.den, self.den * other.num)",
        "    __floordiv__ = lambda self, other: (self.num * other.den) // (self.den * other.num)",
        "",
        "    __pow__ = lambda self, other: Fraction(self.num**other, self.den**other)",
        "    __abs__ = lambda self: self if self.num >= 0 else Fraction(-self.num, self.den)",
        "    __neg__ = lambda self: Fraction(-self.num, self.den)",
        "    __round__ = lambda self, ndigits: round(self.num / self.den, ndigits)",
        "",
        "    __bool__ = lambda self: bool(self.num)",
        "    __int__ = lambda self: self.num // self.den",
        "    __float__ = lambda self: self.num / self.den",
        "    __str__ = lambda self: \"({}, {})\".format(self.num, self.den)",
        "",
        "    __copy__ = lambda self: Fraction(self.num, self.den)",
        "    __hash__ = lambda self: hash((self.num, self.den))",
        "",
        "    __eq__ = lambda self, other: self.num * other.den == other.num * self.den",
        "    __ne__ = lambda self, other: self.num * other.den != other.num * self.den",
        "    __lt__ = lambda self, other: self.num * other.den < other.num * self.den",
        "    __gt__ = lambda self, other: self.num * other.den > other.num * self.den",
        "    __le__ = lambda self, other: self.num * other.den <= other.num * self.den",
        "    __ge__ = lambda self, other: self.num * other.den >= other.num * self.den",
        "",
        "    __repr__ = lambda self: \"Fraction({}, {})\".format(self.num, self.den)",
        "",
        "",
        "def limit_denominator(frac, max_den=1000000):",
        "    if frac.den <= max_den:",
        "        return frac",
        "",
        "    p0, q0, p1, q1 = 0, 1, 1, 0",
        "    n, d = frac.num, frac.den",
        "    while True:",
        "        a = n // d",
        "        q2 = q0 + a * q1",
        "        if q2 > max_den:",
        "            break",
        "        p0, q0, p1, q1 = p1, q1, p0 + a * p1, q2",
        "        n, d = d, n - a * d",
        "",
        "    k = (max_den - q0) // q1",
        "    bound1 = Fraction(p0 + k * p1, q0 + k * q1)",
        "    bound2 = Fraction(p1, q1)",
        "    return bound2 if abs(bound2 - frac) <= abs(bound1 - frac) else bound1",
        "",
        "$1"
      ],
      "description": "Fraction Template"
    },

    "Continued Fraction Template": {
      "prefix": "ds.cfrac",
      "body": [
        "def CFraction(frac):",
        "    num, den = frac",
        "    yield num // den",
        "    num %= den",
        "    while den != 1:",
        "        num, den = den, num",
        "        yield num // den",
        "        num %= den",
        "",
        "",
        "def CFrac2Frac(cfrac):",
        "    num, den = 1, 0",
        "    for u in reversed(cfrac):",
        "        num, den = den + num * u, num",
        "    return (num, den)",
        "",
        "$1"
      ],
      "description": "Continued Fraction Template"
    },

    "Disjoint-Set (Union Find) Template": {
      "prefix": "ds.dset",
      "body": [
        "class DisjointSetUnion:",
        "    def __init__(self, n):",
        "        self.parent = list(range(n))",
        "        self.size = [1] * n",
        "        self.num_sets = n",
        "",
        "    def find(self, a):",
        "        acopy = a",
        "        while a != self.parent[a]:",
        "            a = self.parent[a]",
        "        while acopy != a:",
        "            self.parent[acopy], acopy = a, self.parent[acopy]",
        "        return a",
        "",
        "    def union(self, a, b):",
        "        a, b = self.find(a), self.find(b)",
        "        if a != b:",
        "            if self.size[a] < self.size[b]:",
        "                a, b = b, a",
        "",
        "            self.num_sets -= 1",
        "            self.parent[b] = a",
        "            self.size[a] += self.size[b]",
        "",
        "    def set_size(self, a):",
        "        return self.size[self.find(a)]",
        "",
        "    def __len__(self):",
        "        return self.num_sets",
        "",
        "",
        "class UnionFind:",
        "    def __init__(self, n):",
        "        self.parent = list(range(n))",
        "",
        "    def find(self, a):",
        "        acopy = a",
        "        while a != self.parent[a]:",
        "            a = self.parent[a]",
        "        while acopy != a:",
        "            self.parent[acopy], acopy = a, self.parent[acopy]",
        "        return a",
        "",
        "    def union(self, a, b):",
        "        self.parent[self.find(b)] = self.find(a)",
        "",
        "$1"
      ],
      "description": "Disjoint-Set (Union Find) Template"
    },

    "Generic Nodes Template": {
      "prefix": "ds.node",
      "body": [
        "class Node:",
        "    def __init__(self, value):",
        "        self.value = value",
        "        self.next = None",
        "        self.prev = None",
        "",
        "    def __repr__(self):",
        "        if not self:",
        "            return \"{}()\".format(self.__class__.__name__)",
        "        return \"{}({})\".format(self.__class__.__name__, self.value)",
        "",
        "$1"
      ],
      "description": "Generic Nodes Template"
    },

    "Linked List Template": {
      "prefix": "ds.llist",
      "body": [
        "class Node:",
        "    def __init__(self, value):",
        "        self.value = value",
        "        self.next = None",
        "        self.prev = None",
        "",
        "    def __repr__(self):",
        "        if not self:",
        "            return \"{}()\".format(self.__class__.__name__)",
        "        return \"{}({})\".format(self.__class__.__name__, self.value)",
        "",
        "",
        "class LinkedList:",
        "    def __init__(self, iterable=None):",
        "        self.sentinel = Node(None)",
        "        self.sentinel.next = self.sentinel",
        "        self.sentinel.prev = self.sentinel",
        "        self.__len = 0",
        "        if iterable is not None:",
        "            self += iterable",
        "",
        "    def get_node(self, index):",
        "        node = self.sentinel",
        "        i = 0",
        "        while i <= index:",
        "            node = node.next",
        "            if node == self.sentinel:",
        "                break",
        "            i += 1",
        "        if node == self.sentinel:",
        "            node = None",
        "        return node",
        "",
        "    def __getitem__(self, index):",
        "        node = self.get_node(index)",
        "        return node.value",
        "",
        "    def __len__(self):",
        "        return self.__len",
        "",
        "    def __setitem__(self, index, value):",
        "        node = self.get_node(index)",
        "        node.value = value",
        "",
        "    def __delitem__(self, index):",
        "        node = self.get_node(index)",
        "        if node:",
        "            node.prev.next = node.next",
        "            if node.next:",
        "                node.next.prev = node.prev",
        "            node.prev = None",
        "            node.next = None",
        "            node.value = None",
        "            self.__len -= 1",
        "",
        "    def __repr__(self):",
        "        return str(self.to_list())",
        "",
        "    def to_list(self):",
        "        elts = []",
        "        curr = self.sentinel.next",
        "        while curr != self.sentinel:",
        "            elts.append(curr.value)",
        "            curr = curr.next",
        "        return elts",
        "",
        "    def append(self, value):",
        "        node = Node(value)",
        "        self.insert_between(node, self.sentinel.prev, self.sentinel)",
        "",
        "    def appendleft(self, value):",
        "        node = Node(value)",
        "        self.insert_between(node, self.sentinel, self.sentinel.next)",
        "",
        "    def insert(self, index, value):",
        "        new_node = Node(value)",
        "        len_ = len(self)",
        "        if len_ == 0:",
        "            self.insert_between(new_node, self.sentinel, self.sentinel)",
        "        elif index >= 0 and index < len_:",
        "            node = self.get_node(index)",
        "            self.insert_between(new_node, node.prev, node)",
        "        elif index == len_:",
        "            self.insert_between(new_node, self.sentinel.prev, self.sentinel)",
        "        else:",
        "            raise IndexError",
        "        self.__len += 1",
        "",
        "    def insert_between(self, node, left_node, right_node):",
        "        if node and left_node and right_node:",
        "            node.prev = left_node",
        "            node.next = right_node",
        "            left_node.next = node",
        "            right_node.prev = node",
        "        else:",
        "            raise IndexError",
        "",
        "    def merge_left(self, other):",
        "        self.sentinel.next.prev = other.sentinel.prev",
        "        other.sentinel.prev.next = self.sentinel.next",
        "        self.sentinel.next = other.sentinel.next",
        "        self.sentinel.next.prev = self.sentinel",
        "",
        "    def merge_right(self, other):",
        "        self.sentinel.prev.next = other.sentinel.next",
        "        other.sentinel.next.prev = self.sentinel.prev",
        "        self.sentinel.prev = other.sentinel.prev",
        "        self.sentinel.prev.next = self.sentinel",
        "",
        "$1"
      ],
      "description": "Linked List Template"
    },

    "Range Query Data Structure Template": {
      "prefix": "ds.rquery",
      "body": [
        "class RangeQuery:",
        "    def __init__(self, data, func=min):",
        "        self.func = func",
        "        self._data = _data = [list(data)]",
        "        i, n = 1, len(_data[0])",
        "        while 2 * i <= n:",
        "            prev = _data[-1]",
        "            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])",
        "            i <<= 1",
        "",
        "    def query(self, start, stop):",
        "        \"\"\"func of data[start, stop)\"\"\"",
        "        depth = (stop - start).bit_length() - 1",
        "        return self.func(self._data[depth][start], self._data[depth][stop - (1 << depth)])",
        "",
        "    def __getitem__(self, idx):",
        "        return self._data[0][idx]",
        "",
        "$1"
      ],
      "description": "Range Query Data Structure Template"
    },

    "(Lazy) Segment Tree Template": {
      "prefix": "ds.lstree",
      "body": [
        "class LazySegmentTree:",
        "    def __init__(self, data, default=0, func=max):",
        "        \"\"\"initialize the lazy segment tree with data\"\"\"",
        "        self._default = default",
        "        self._func = func",
        "",
        "        self._len = len(data)",
        "        self._size = _size = 1 << (self._len - 1).bit_length()",
        "        self._lazy = [0] * (2 * _size)",
        "",
        "        self.data = [default] * (2 * _size)",
        "        self.data[_size:_size + self._len] = data",
        "        for i in reversed(range(_size)):",
        "            self.data[i] = func(self.data[i + i], self.data[i + i + 1])",
        "",
        "    def __len__(self):",
        "        return self._len",
        "",
        "    def _push(self, idx):",
        "        \"\"\"push query on idx to its children\"\"\"",
        "        # Let the children know of the queries",
        "        q, self._lazy[idx] = self._lazy[idx], 0",
        "",
        "        self._lazy[2 * idx] += q",
        "        self._lazy[2 * idx + 1] += q",
        "        self.data[2 * idx] += q",
        "        self.data[2 * idx + 1] += q",
        "",
        "    def _update(self, idx):",
        "        \"\"\"updates the node idx to know of all queries applied to it via its ancestors\"\"\"",
        "        for i in reversed(range(1, idx.bit_length())):",
        "            self._push(idx >> i)",
        "",
        "    def _build(self, idx):",
        "        \"\"\"make the changes to idx be known to its ancestors\"\"\"",
        "        idx >>= 1",
        "        while idx:",
        "            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1]) + self._lazy[idx]",
        "            idx >>= 1",
        "",
        "    def add(self, start, stop, value):",
        "        \"\"\"lazily add value to [start, stop)\"\"\"",
        "        start = start_copy = start + self._size",
        "        stop = stop_copy = stop + self._size",
        "        while start < stop:",
        "            if start & 1:",
        "                self._lazy[start] += value",
        "                self.data[start] += value",
        "                start += 1",
        "            if stop & 1:",
        "                stop -= 1",
        "                self._lazy[stop] += value",
        "                self.data[stop] += value",
        "            start >>= 1",
        "            stop >>= 1",
        "",
        "        # Tell all nodes above of the updated area of the updates",
        "        self._build(start_copy)",
        "        self._build(stop_copy - 1)",
        "",
        "    def query(self, start, stop, default=0):",
        "        \"\"\"func of data[start, stop)\"\"\"",
        "        start += self._size",
        "        stop += self._size",
        "",
        "        # Apply all the lazily stored queries",
        "        self._update(start)",
        "        self._update(stop - 1)",
        "",
        "        res = default",
        "        while start < stop:",
        "            if start & 1:",
        "                res = self._func(res, self.data[start])",
        "                start += 1",
        "            if stop & 1:",
        "                stop -= 1",
        "                res = self._func(res, self.data[stop])",
        "            start >>= 1",
        "            stop >>= 1",
        "        return res",
        "",
        "    def __repr__(self):",
        "        return \"LazySegmentTree({0})\".format(self.data)",
        "",
        "$1"
      ],
      "description": "(Lazy) Segment Tree Template"
    },

    "Persistent Segment Tree Template": {
      "prefix": "ds.pstree",
      "body": [
        "BIG = 10**9",
        "",
        "vals = []",
        "L = []",
        "R = []",
        "",
        "",
        "def create(n):",
        "    \"\"\"create a persistant segment tree of size n\"\"\"",
        "",
        "    ind = len(vals)",
        "    vals.append(BIG)",
        "",
        "    L.append(-1)",
        "    R.append(-1)",
        "",
        "    if n == 1:",
        "        L[ind] = -1",
        "        R[ind] = -1",
        "    else:",
        "        mid = n // 2",
        "        L[ind] = create(mid)",
        "        R[ind] = create(n - mid)",
        "    return ind",
        "",
        "",
        "def setter(ind, i, val, n):",
        "    \"\"\"set set[i] = val for segment tree ind, of size n\"\"\"",
        "",
        "    ind2 = len(vals)",
        "    vals.append(BIG)",
        "",
        "    L.append(-1)",
        "    R.append(-1)",
        "",
        "    if n == 1:",
        "        vals[ind2] = val",
        "        return ind2",
        "",
        "    mid = n // 2",
        "    if i < mid:",
        "        L[ind2] = setter(L[ind], i, val, mid)",
        "        R[ind2] = R[ind]",
        "    else:",
        "        L[ind2] = L[ind]",
        "        R[ind2] = setter(R[ind], i - mid, val, n - mid)",
        "    vals[ind2] = min(vals[L[ind2]], vals[R[ind2]])",
        "    return ind2",
        "",
        "",
        "def minimum(ind, l, r, n):",
        "    \"\"\"find mimimum of set[l:r] for segment tree ind, of size n\"\"\"",
        "",
        "    if l == 0 and r == n:",
        "        return vals[ind]",
        "    mid = n // 2",
        "    if r <= mid:",
        "        return minimum(L[ind], l, r, mid)",
        "    elif mid <= l:",
        "        return minimum(R[ind], l - mid, r - mid, n - mid)",
        "    else:",
        "        return min(minimum(L[ind], l, mid, mid), minimum(R[ind], 0, r - mid, n - mid))",
        "",
        "$1"
      ],
      "description": "Persistent Segment Tree Template"
    },

    "Sorted List Template": {
      "prefix": "ds.slist",
      "body": [
        "class SortedList:",
        "    def __init__(self, iterable=[], _load=200):",
        "        \"\"\"Initialize sorted list instance.\"\"\"",
        "        values = sorted(iterable)",
        "        self._len = _len = len(values)",
        "        self._load = _load",
        "        self._lists = _lists = [values[i:i + _load] for i in range(0, _len, _load)]",
        "        self._list_lens = [len(_list) for _list in _lists]",
        "        self._mins = [_list[0] for _list in _lists]",
        "        self._fen_tree = []",
        "        self._rebuild = True",
        "",
        "    def _fen_build(self):",
        "        \"\"\"Build a fenwick tree instance.\"\"\"",
        "        self._fen_tree[:] = self._list_lens",
        "        _fen_tree = self._fen_tree",
        "        for i in range(len(_fen_tree)):",
        "            if i | i + 1 < len(_fen_tree):",
        "                _fen_tree[i | i + 1] += _fen_tree[i]",
        "        self._rebuild = False",
        "",
        "    def _fen_update(self, index, value):",
        "        \"\"\"Update `fen_tree[index] += value`.\"\"\"",
        "        if not self._rebuild:",
        "            _fen_tree = self._fen_tree",
        "            while index < len(_fen_tree):",
        "                _fen_tree[index] += value",
        "                index |= index + 1",
        "",
        "    def _fen_query(self, end):",
        "        \"\"\"Return `sum(_fen_tree[:end])`.\"\"\"",
        "        if self._rebuild:",
        "            self._fen_build()",
        "",
        "        _fen_tree = self._fen_tree",
        "        x = 0",
        "        while end:",
        "            x += _fen_tree[end - 1]",
        "            end &= end - 1",
        "        return x",
        "",
        "    def _fen_findkth(self, k):",
        "        \"\"\"Return a pair of (the largest `idx` such that `sum(_fen_tree[:idx]) <= k`, `k - sum(_fen_tree[:idx])`).\"\"\"",
        "        _list_lens = self._list_lens",
        "        if k < _list_lens[0]:",
        "            return 0, k",
        "        if k >= self._len - _list_lens[-1]:",
        "            return len(_list_lens) - 1, k + _list_lens[-1] - self._len",
        "        if self._rebuild:",
        "            self._fen_build()",
        "",
        "        _fen_tree = self._fen_tree",
        "        idx = -1",
        "        for d in reversed(range(len(_fen_tree).bit_length())):",
        "            right_idx = idx + (1 << d)",
        "            if right_idx < len(_fen_tree) and k >= _fen_tree[right_idx]:",
        "                idx = right_idx",
        "                k -= _fen_tree[idx]",
        "        return idx + 1, k",
        "",
        "    def _delete(self, pos, idx):",
        "        \"\"\"Delete value at the given `(pos, idx)`.\"\"\"",
        "        _lists = self._lists",
        "        _mins = self._mins",
        "        _list_lens = self._list_lens",
        "",
        "        self._len -= 1",
        "        self._fen_update(pos, -1)",
        "        del _lists[pos][idx]",
        "        _list_lens[pos] -= 1",
        "",
        "        if _list_lens[pos]:",
        "            _mins[pos] = _lists[pos][0]",
        "        else:",
        "            del _lists[pos]",
        "            del _list_lens[pos]",
        "            del _mins[pos]",
        "            self._rebuild = True",
        "",
        "    def _loc_left(self, value):",
        "        \"\"\"Return an index pair that corresponds to the first position of `value` in the sorted list.\"\"\"",
        "        if not self._len:",
        "            return 0, 0",
        "",
        "        _lists = self._lists",
        "        _mins = self._mins",
        "",
        "        lo, pos = -1, len(_lists) - 1",
        "        while lo + 1 < pos:",
        "            mi = (lo + pos) >> 1",
        "            if value <= _mins[mi]:",
        "                pos = mi",
        "            else:",
        "                lo = mi",
        "",
        "        if pos and value <= _lists[pos - 1][-1]:",
        "            pos -= 1",
        "",
        "        _list = _lists[pos]",
        "        lo, idx = -1, len(_list)",
        "        while lo + 1 < idx:",
        "            mi = (lo + idx) >> 1",
        "            if value <= _list[mi]:",
        "                idx = mi",
        "            else:",
        "                lo = mi",
        "",
        "        return pos, idx",
        "",
        "    def _loc_right(self, value):",
        "        \"\"\"Return an index pair that corresponds to the last position of `value` in the sorted list.\"\"\"",
        "        if not self._len:",
        "            return 0, 0",
        "",
        "        _lists = self._lists",
        "        _mins = self._mins",
        "",
        "        pos, hi = 0, len(_lists)",
        "        while pos + 1 < hi:",
        "            mi = (pos + hi) >> 1",
        "            if value < _mins[mi]:",
        "                hi = mi",
        "            else:",
        "                pos = mi",
        "",
        "        _list = _lists[pos]",
        "        lo, idx = -1, len(_list)",
        "        while lo + 1 < idx:",
        "            mi = (lo + idx) >> 1",
        "            if value < _list[mi]:",
        "                idx = mi",
        "            else:",
        "                lo = mi",
        "",
        "        return pos, idx",
        "",
        "    def add(self, value):",
        "        \"\"\"Add `value` to sorted list.\"\"\"",
        "        _load = self._load",
        "        _lists = self._lists",
        "        _mins = self._mins",
        "        _list_lens = self._list_lens",
        "",
        "        self._len += 1",
        "        if _lists:",
        "            pos, idx = self._loc_right(value)",
        "            self._fen_update(pos, 1)",
        "            _list = _lists[pos]",
        "            _list.insert(idx, value)",
        "            _list_lens[pos] += 1",
        "            _mins[pos] = _list[0]",
        "            if _load + _load < len(_list):",
        "                _lists.insert(pos + 1, _list[_load:])",
        "                _list_lens.insert(pos + 1, len(_list) - _load)",
        "                _mins.insert(pos + 1, _list[_load])",
        "                _list_lens[pos] = _load",
        "                del _list[_load:]",
        "                self._rebuild = True",
        "        else:",
        "            _lists.append([value])",
        "            _mins.append(value)",
        "            _list_lens.append(1)",
        "            self._rebuild = True",
        "",
        "    def discard(self, value):",
        "        \"\"\"Remove `value` from sorted list if it is a member.\"\"\"",
        "        _lists = self._lists",
        "        if _lists:",
        "            pos, idx = self._loc_right(value)",
        "            if idx and _lists[pos][idx - 1] == value:",
        "                self._delete(pos, idx - 1)",
        "",
        "    def remove(self, value):",
        "        \"\"\"Remove `value` from sorted list; `value` must be a member.\"\"\"",
        "        _len = self._len",
        "        self.discard(value)",
        "        if _len == self._len:",
        "            raise ValueError('{0!r} not in list'.format(value))",
        "",
        "    def pop(self, index=-1):",
        "        \"\"\"Remove and return value at `index` in sorted list.\"\"\"",
        "        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
        "        value = self._lists[pos][idx]",
        "        self._delete(pos, idx)",
        "        return value",
        "",
        "    def bisect_left(self, value):",
        "        \"\"\"Return the first index to insert `value` in the sorted list.\"\"\"",
        "        pos, idx = self._loc_left(value)",
        "        return self._fen_query(pos) + idx",
        "",
        "    def bisect_right(self, value):",
        "        \"\"\"Return the last index to insert `value` in the sorted list.\"\"\"",
        "        pos, idx = self._loc_right(value)",
        "        return self._fen_query(pos) + idx",
        "",
        "    def count(self, value):",
        "        \"\"\"Return number of occurrences of `value` in the sorted list.\"\"\"",
        "        return self.bisect_right(value) - self.bisect_left(value)",
        "",
        "    def __len__(self):",
        "        \"\"\"Return the size of the sorted list.\"\"\"",
        "        return self._len",
        "",
        "    def __getitem__(self, index):",
        "        \"\"\"Lookup value at `index` in sorted list.\"\"\"",
        "        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
        "        return self._lists[pos][idx]",
        "",
        "    def __delitem__(self, index):",
        "        \"\"\"Remove value at `index` from sorted list.\"\"\"",
        "        pos, idx = self._fen_findkth(self._len + index if index < 0 else index)",
        "        self._delete(pos, idx)",
        "",
        "    def __contains__(self, value):",
        "        \"\"\"Return true if `value` is an element of the sorted list.\"\"\"",
        "        _lists = self._lists",
        "        if _lists:",
        "            pos, idx = self._loc_left(value)",
        "            return idx < len(_lists[pos]) and _lists[pos][idx] == value",
        "        return False",
        "",
        "    def __iter__(self):",
        "        \"\"\"Return an iterator over the sorted list.\"\"\"",
        "        return (value for _list in self._lists for value in _list)",
        "",
        "    def __reversed__(self):",
        "        \"\"\"Return a reverse iterator over the sorted list.\"\"\"",
        "        return (value for _list in reversed(self._lists) for value in reversed(_list))",
        "",
        "    def __repr__(self):",
        "        \"\"\"Return string representation of sorted list.\"\"\"",
        "        return 'SortedList({0})'.format(list(self))",
        "",
        ""
      ],
      "description": "Sorted List Template"
    },

    "Treap Template": {
      "prefix": "ds.treap",
      "body": [
        "",
        "class TreapSet(TreapMultiSet):",
        "    def add(self, key):",
        "        self.root, duplicate = treap_insert_unique(self.root, key)",
        "        if not duplicate:",
        "            self.size += 1",
        "",
        "    def __repr__(self):",
        "        return \"TreapSet({})\".format(list(self))",
        "",
        "",
        "class TreapHashSet(TreapMultiSet):",
        "    def __init__(self, data=None):",
        "        if data:",
        "            self.keys = set(data)",
        "            super(TreapHashSet, self).__init__(self.keys)",
        "        else:",
        "            self.keys = set()",
        "",
        "    def add(self, key):",
        "        if key not in self.keys:",
        "            self.keys.add(key)",
        "            super(TreapHashSet, self).add(key)",
        "",
        "    def remove(self, key):",
        "        self.keys.remove(key)",
        "        super(TreapHashSet, self).remove(key)",
        "",
        "    def discard(self, key):",
        "        if key in self.keys:",
        "            self.remove(key)",
        "",
        "    def __contains__(self, key):",
        "        return key in self.keys",
        "",
        "    def __repr__(self):",
        "        return \"TreapHashSet({})\".format(list(self))",
        "",
        "",
        "class TreapHashMap(TreapMultiSet):",
        "    def __init__(self, data=None):",
        "        if data:",
        "            self.map = dict(data)",
        "            super(TreapHashMap, self).__init__(self.map.keys())",
        "        else:",
        "            self.map = dict()",
        "",
        "    def __setitem__(self, key, value):",
        "        if key not in self.map:",
        "            super(TreapHashMap, self).add(key)",
        "        self.map[key] = value",
        "",
        "    def __getitem__(self, key):",
        "        return self.map[key]",
        "",
        "    def add(self, key):",
        "        raise TypeError(\"add on TreapHashMap\")",
        "",
        "    def get(self, key, default=None):",
        "        return self.map.get(key, default=default)",
        "",
        "    def remove(self, key):",
        "        self.map.pop(key)",
        "        super(TreapHashMap, self).remove(key)",
        "",
        "    def discard(self, key):",
        "        if key in self.map:",
        "            self.remove(key)",
        "",
        "    def __contains__(self, key):",
        "        return key in self.map",
        "",
        "    def __repr__(self):",
        "        return \"TreapHashMap({})\".format(list(self))",
        "",
        "",
        "left_child = [0]",
        "right_child = [0]",
        "treap_keys = [0]",
        "treap_prior = [0.0]",
        "",
        "",
        "def treap_builder(sorted_data):",
        "    \"\"\"Build a treap in O(n) time using sorted data\"\"\"",
        "    def build(begin, end):",
        "        if begin == end:",
        "            return 0",
        "        mid = (begin + end) // 2",
        "        root = treap_create_node(sorted_data[mid])",
        "        left_child[root] = build(begin, mid)",
        "        right_child[root] = build(mid + 1, end)",
        "",
        "        # sift down the priorities",
        "        ind = root",
        "        while True:",
        "            lc = left_child[ind]",
        "            rc = right_child[ind]",
        "",
        "            if lc and treap_prior[lc] > treap_prior[ind]:",
        "                if rc and treap_prior[rc] > treap_prior[rc]:",
        "                    treap_prior[ind], treap_prior[rc] = treap_prior[rc], treap_prior[ind]",
        "                    ind = rc",
        "                else:",
        "                    treap_prior[ind], treap_prior[lc] = treap_prior[lc], treap_prior[ind]",
        "                    ind = lc",
        "            elif rc and treap_prior[rc] > treap_prior[ind]:",
        "                treap_prior[ind], treap_prior[rc] = treap_prior[rc], treap_prior[ind]",
        "                ind = rc",
        "            else:",
        "                break",
        "        return root",
        "",
        "    return build(0, len(sorted_data))",
        "",
        "",
        "def treap_create_node(key):",
        "    treap_keys.append(key)",
        "    treap_prior.append(random.random())",
        "    left_child.append(0)",
        "    right_child.append(0)",
        "    return len(treap_keys) - 1",
        "",
        "",
        "def treap_split(root, key):",
        "    left_pos = right_pos = 0",
        "    while root:",
        "        if key < treap_keys[root]:",
        "            left_child[right_pos] = right_pos = root",
        "            root = left_child[root]",
        "        else:",
        "            right_child[left_pos] = left_pos = root",
        "            root = right_child[root]",
        "    left, right = right_child[0], left_child[0]",
        "    right_child[left_pos] = left_child[right_pos] = right_child[0] = left_child[0] = 0",
        "    return left, right",
        "",
        "",
        "def treap_merge(left, right):",
        "    where, pos = left_child, 0",
        "    while left and right:",
        "        if treap_prior[left] > treap_prior[right]:",
        "            where[pos] = pos = left",
        "            where = right_child",
        "            left = right_child[left]",
        "        else:",
        "            where[pos] = pos = right",
        "            where = left_child",
        "            right = left_child[right]",
        "    where[pos] = left or right",
        "    node = left_child[0]",
        "    left_child[0] = 0",
        "    return node",
        "",
        "",
        "def treap_insert(root, key):",
        "    if not root:",
        "        return treap_create_node(key)",
        "    left, right = treap_split(root, key)",
        "    return treap_merge(treap_merge(left, treap_create_node(key)), right)",
        "",
        "",
        "def treap_insert_unique(root, key):",
        "    if not root:",
        "        return treap_create_node(key), False",
        "    left, right = treap_split(root, key)",
        "    if left and treap_keys[left] == key:",
        "        return treap_merge(left, right), True",
        "    return treap_merge(treap_merge(left, treap_create_node(key)), right), False",
        "",
        "",
        "def treap_erase(root, key):",
        "    if not root:",
        "        raise KeyError(key)",
        "    if treap_keys[root] == key:",
        "        return treap_merge(left_child[root], right_child[root])",
        "    node = root",
        "    while root and treap_keys[root] != key:",
        "        parent = root",
        "        root = left_child[root] if key < treap_keys[root] else right_child[root]",
        "    if not root:",
        "        raise KeyError(key)",
        "    if root == left_child[parent]:",
        "        left_child[parent] = treap_merge(left_child[root], right_child[root])",
        "    else:",
        "        right_child[parent] = treap_merge(left_child[root], right_child[root])",
        "",
        "    return node",
        "",
        "",
        "def treap_ceiling(root, key):",
        "    while root and treap_keys[root] < key:",
        "        root = right_child[root]",
        "    if not root:",
        "        return 0",
        "    min_node = root",
        "    min_key = treap_keys[root]",
        "    while root:",
        "        if treap_keys[root] < key:",
        "            root = right_child[root]",
        "        else:",
        "            if treap_keys[root] < min_key:",
        "                min_key = treap_keys[root]",
        "                min_node = root",
        "            root = left_child[root]",
        "    return min_node",
        "",
        "",
        "def treap_higher(root, key):",
        "    while root and treap_keys[root] <= key:",
        "        root = right_child[root]",
        "    if not root:",
        "        return 0",
        "    min_node = root",
        "    min_key = treap_keys[root]",
        "    while root:",
        "        if treap_keys[root] <= key:",
        "            root = right_child[root]",
        "        else:",
        "            if treap_keys[root] < min_key:",
        "                min_key = treap_keys[root]",
        "                min_node = root",
        "            root = left_child[root]",
        "    return min_node",
        "",
        "",
        "def treap_floor(root, key):",
        "    while root and treap_keys[root] > key:",
        "        root = left_child[root]",
        "    if not root:",
        "        return 0",
        "    max_node = root",
        "    max_key = treap_keys[root]",
        "    while root:",
        "        if treap_keys[root] > key:",
        "            root = left_child[root]",
        "        else:",
        "            if treap_keys[root] > max_key:",
        "                max_key = treap_keys[root]",
        "                max_node = root",
        "            root = right_child[root]",
        "    return max_node",
        "",
        "",
        "def treap_lower(root, key):",
        "    while root and treap_keys[root] >= key:",
        "        root = left_child[root]",
        "    if not root:",
        "        return 0",
        "    max_node = root",
        "    max_key = treap_keys[root]",
        "    while root:",
        "        if treap_keys[root] >= key:",
        "            root = left_child[root]",
        "        else:",
        "            if treap_keys[root] > max_key:",
        "                max_key = treap_keys[root]",
        "                max_node = root",
        "            root = right_child[root]",
        "    return max_node",
        "",
        "",
        "def treap_min(root):",
        "    if not root:",
        "        raise ValueError(\"min on empty treap\")",
        "    while left_child[root]:",
        "        root = left_child[root]",
        "    return root",
        "",
        "",
        "def treap_max(root):",
        "    if not root:",
        "        raise ValueError(\"max on empty treap\")",
        "    while right_child[root]:",
        "        root = right_child[root]",
        "    return root",
        "",
        ""
      ],
      "description": "Treap Template"
    },

    "Trie Template": {
      "prefix": "ds.trie",
      "body": [
        "class Trie:",
        "    def __init__(self, *words):",
        "        self.root = dict()",
        "        for word in words:",
        "            self.add(word)",
        "",
        "    def add(self, word):",
        "        current_dict = self.root",
        "        for letter in word:",
        "            current_dict = current_dict.setdefault(letter, dict())",
        "        current_dict[\"_end_\"] = True",
        "",
        "    def __contains__(self, word):",
        "        current_dict = self.root",
        "        for letter in word:",
        "            if letter not in current_dict:",
        "                return False",
        "            current_dict = current_dict[letter]",
        "        return \"_end_\" in current_dict",
        "",
        "    def __delitem__(self, word):",
        "        current_dict = self.root",
        "        nodes = [current_dict]",
        "        for letter in word:",
        "            current_dict = current_dict[letter]",
        "            nodes.append(current_dict)",
        "        del current_dict[\"_end_\"]",
        "",
        "",
        ""
      ],
      "description": "Trie Template"
    },

    "2-satisfiability Template": {
      "prefix": "ds.twosat",
      "body": [
        "def scc(graph):",
        "    \"\"\"",
        "    Finds what strongly connected components each node",
        "    is a part of in a directed graph,",
        "    it also finds a weak topological ordering of the nodes",
        "    \"\"\"",
        "    n = len(graph)",
        "    comp = [-1] * n",
        "    top_order = []",
        "",
        "    Q = []",
        "    stack = []",
        "    new_node = None",
        "    for root in range(n):",
        "        if comp[root] >= 0:",
        "            continue",
        "",
        "        # Do a dfs while keeping track of depth",
        "        Q.append(root)",
        "        root_depth = len(top_order)",
        "        while Q:",
        "            node = Q.pop()",
        "            if node >= 0:",
        "                if comp[node] >= 0:",
        "                    continue",
        "                # First time",
        "",
        "                # Index the node",
        "                comp[node] = len(top_order) + len(stack)",
        "                stack.append(node)",
        "",
        "                # Do a dfs",
        "                Q.append(~node)",
        "                Q += graph[node]",
        "            else:",
        "                # Second time",
        "                node = ~node",
        "",
        "                # calc low link",
        "                low = index = comp[node]",
        "                for nei in graph[node]:",
        "                    if root_depth <= comp[nei]:",
        "                        low = min(low, comp[nei])",
        "",
        "                # low link same as index, so create SCC",
        "                if low == index:",
        "                    while new_node != node:",
        "                        new_node = stack.pop()",
        "                        comp[new_node] = index",
        "                        top_order.append(new_node)",
        "                else:",
        "                    comp[node] = low",
        "",
        "    top_order.reverse()",
        "    return comp, top_order",
        "",
        "",
        "class TwoSat:",
        "    def __init__(self, n):",
        "        self.n = n",
        "        self.graph = [[] for _ in range(2 * n)]",
        "",
        "    def _imply(self, x, y):",
        "        self.graph[x].append(y if y >= 0 else 2 * self.n + y)",
        "",
        "    def either(self, x, y):",
        "        \"\"\"either x or y must be True\"\"\"",
        "        self._imply(~x, y)",
        "        self._imply(~y, x)",
        "",
        "    def set(self, x):",
        "        \"\"\"x must be True\"\"\"",
        "        self._imply(~x, x)",
        "",
        "    def solve(self):",
        "        comp, top_order = scc(self.graph)",
        "        for x in range(self.n):",
        "            if comp[x] == comp[~x]:",
        "                return False, None",
        "",
        "        self.values = [None] * self.n",
        "        for x in reversed(top_order):",
        "            y = x if x < self.n else (2 * self.n - 1 - x)",
        "            if self.values[y] is None:",
        "                self.values[y] = x < self.n",
        "        return True, self.values",
        "",
        ""
      ],
      "description": "2-satisfiability Template"
    }
}