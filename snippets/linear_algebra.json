{
	"Matrix Arithmetic, Exponentiation, Determinant, and Inverse Template": {
		"prefix": "lalg.matrix",
		"body": "from copy import deepcopy\n\ntranspose = lambda mat: [list(col) for col in zip(*mat)]\n\nminor = lambda mat, i, j: [row[:j] + row[j + 1:] for row in (mat[:i] + mat[i + 1:])]\n\nmat_add = lambda *mat: [[sum(elements) for elements in zip(*row)] for row in zip(*mat)]\n\nmat_sub = lambda A, B: [[i - j for i, j in zip(*row)] for row in zip(A, B)]\n\nmat_mul = lambda A, B: [[sum(i * j for i, j in zip(row, col)) for col in zip(*B)] for row in A]\n\nvec_mul = lambda mat, vec: [sum(a * b for a, b in zip(row, vec)) for row in mat]\n\n\ndef eye(m):\n    \"\"\"returns an indentity matrix of order m\"\"\"\n    identity = [[0] * m for _ in range(m)]\n    for i, row in enumerate(identity):\n        row[i] = 1\n    return identity\n\n\ndef mat_pow(mat, power):\n    \"\"\"returns mat**power\"\"\"\n    if power < 0:\n        return mat_pow(mat_inv(mat), -power)\n\n    result = eye(len(mat))\n    if power == 0:\n        return result\n\n    while power > 1:\n        if power & 1 == 1:\n            result = mat_mul(result, mat)\n        mat = mat_mul(mat, mat)\n        power >>= 1\n    return mat_mul(result, mat)\n\n\ndef mat_inv(A):\n    B = deepcopy(A)\n    n = len(A)\n    col = list(range(n))\n\n    tmp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        tmp[i][i] = 1\n\n    for i in range(n):\n        r = c = i\n        for j in range(i, n):\n            for k in range(i, n):\n                if abs(B[j][k]) > abs(B[r][c]):\n                    r, c = j, k\n        if B[r][c] == 0:\n            return B\n\n        B[i], B[r] = B[r], B[i]\n        tmp[i], tmp[r] = tmp[r], tmp[i]\n        for j in range(n):\n            B[j][i], B[j][c] = B[j][c], B[j][i]\n            tmp[j][i], tmp[j][c] = tmp[j][c], tmp[j][i]\n        col[i], col[c] = col[c], col[i]\n        v = B[i][i]\n        for j in range(i + 1, n):\n            f = B[j][i] / v\n            B[j][i] = 0\n            for k in range(i + 1, n):\n                B[j][k] -= f * B[i][k]\n            for k in range(n):\n                tmp[j][k] -= f * tmp[i][k]\n\n        for j in range(i + 1, n):\n            B[i][j] /= v\n\n        for j in range(n):\n            tmp[i][j] /= v\n        B[i][i] = 1\n\n    for i in reversed(range(n)):\n        for j in range(i):\n            v = B[j][i]\n            for k in range(n):\n                tmp[j][k] -= v * tmp[i][k]\n\n    for i in range(n):\n        for j in range(n):\n            B[col[i]][col[j]] = tmp[i][j]\n    return B\n",
		"description": "Matrix Arithmetic, Exponentiation, Determinant, and Inverse Template"
	},
	"Gaussian Elimination Template": {
		"prefix": "lalg.maxxor",
		"body": "\"\"\"\nMaximizes xor of values in a list (works with big integers)\n\nExample:\n>>>> A = [10**20, 3, 6, 4]\n>>>> I = max_xor(A)\n>>>> xor = 0\n>>>> for i in I:\n....    xor ^= A[i]\n....\n>>>> xor\n100000000000000000007\n\n\"\"\"\n\n\ndef max_xor(A):\n    \"\"\"\n    Input:\n    List A of non-negative integers\n    Output:\n    I such that xor(A[i] for i in I) is maximized\n    \"\"\"\n    base = []\n    how = {}\n    reduced_base = {}\n\n    for i in range(len(A)):\n        a = A[i]\n        tmp = 0\n        while a:\n            b = a.bit_length() - 1\n            if b in reduced_base:\n                a ^= reduced_base[b]\n                tmp ^= how[b]\n            else:\n                reduced_base[b] = a\n                how[b] = tmp | (1 << len(base))\n                base.append(i)\n                break\n    x = 0\n    tmp = 0\n    for j in sorted(reduced_base, reverse=True):\n        if not x & (1 << j):\n            x ^= reduced_base[j]\n            tmp ^= how[j]\n    I = [base[j] for j in range(len(base)) if tmp & (1 << j)]\n    return I\n",
		"description": "Gaussian Elimination Template"
	},
	"Multivariable Chinese Remainder Theorem Template": {
		"prefix": "lalg.crt",
		"body": "mat_sub = lambda A, B: [[i - j for i, j in zip(*row)] for row in zip(A, B)]\n\nmat_mul = lambda A, B: [[sum(i * j for i, j in zip(row, col)) for col in zip(*B)] for row in A]\n\n\ndef gcd(x, y):\n    \"\"\"greatest common divisor of x and y\"\"\"\n    while y:\n        x, y = y, x % y\n    return x\n\n\ndef extended_gcd(a, b):\n    \"\"\"returns gcd(a, b), s, r s.t. a * s + b * r == gcd(a, b)\"\"\"\n    s, old_s = 0, 1\n    r, old_r = b, a\n    while r:\n        q = old_r // r\n        old_r, r = r, old_r - q * r\n        old_s, s = s, old_s - q * s\n    return old_r, old_s, (old_r - old_s * a) // b if b else 0\n\n\ndef modinv(a, m):\n    \"\"\"returns the modular inverse of a w.r.t. to m\"\"\"\n    amodm = a % m\n    g, x, _ = extended_gcd(amodm, m)\n    return x % m if g == 1 else None\n\n\ndef pivot(A, m):\n    \"\"\"returns the pivot of A and m\"\"\"\n    result = [0] * len(A)\n    for i, Ai in enumerate(A):\n        for j, Aij in enumerate(Ai):\n            if gcd(Aij, m[i]) == 1:\n                result[i] = j\n    return result\n\n\ndef is_sol(A, x, b, m):\n    \"\"\"checks if Ax = b mod m\"\"\"\n    ax_b = mat_sub(mat_mul(A, x), b)\n    for i, mod in enumerate(m):\n        if ax_b[i] % mod:\n            return False\n    return True\n\n\ndef mcrt(A, b, m):\n    \"\"\"returns x s.t. Ax = b mod m\"\"\"\n    piv = pivot(A, m)\n    x = [0] * len(A)\n    m_prod = 1\n    for i, Ai in enumerate(A):\n        tot = sum(Ai[k] * x[k] for k in range(len(A)))\n        tmp = (modinv(m_prod * Ai[piv[i]], m[i]) * (b[i] - tot)) % m[i]\n        x[piv[i]] += tmp * m_prod\n        m_prod *= m[i]\n    return x\n",
		"description": "Multivariable Chinese Remainder Theorem Template"
	}
}